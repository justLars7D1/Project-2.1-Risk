package bot.Algorithms.MCTS;

import java.util.ArrayList;
import java.util.List;

/**
 * Represents a state in a tree of states
 */
public abstract class StateNode implements State {

    /**
     * The parent node of the state (Corresponds to a state before taking a certain action)
     */
    private StateNode parent;

    /**
     * The children of the state that have been generated
     */
    private List<StateNode> childNodes;

    /**
     * The actions that could be taken in this state
     */
    private Action[] actions;

    /**
     * The number of times this state has been visited in the search algorithm
     */
    private int numTimesSampled;

    /**
     * The total score of the state. This is calculated by the monte carlo simulation, summing up all underneath state
     * values of the children of this state
     */
    private double totalScore;

    /**
     * The default constructor
     */
    public StateNode(Action[] actions) {
        childNodes = new ArrayList<>();
        this.actions = actions;
    }

    /**
     * Performs the actions of the current state, generating the children of this state
     *
     * @return The state that was generated by the first action
     */
    public StateNode performActions() {
        StateNode firstNewChildNode = null;
        for (int i = 0; i < actions.length; i++) {
            StateNode newState = actions[i].perform(this);

            newState.parent = this;

            if (firstNewChildNode == null) firstNewChildNode = newState;
            childNodes.add(newState);
        }
        return firstNewChildNode;
    }

    /**
     * Check if a state is terminal
     *
     * @return Whether the state is terminal
     */
    public abstract boolean isTerminal();

    /**
     * Simulate an action on this state, creating a fake new state that results from this action
     *
     * @param a The action to perform
     * @return The state that comes forward from this simulation
     */
    public abstract StateNode simulate(Action a);

    /**
     * Calculate the value of the given state node
     * @return The state value
     */
    public abstract double calculateStateValue();

    /**
     * Get the child nodes of the state
     *
     * @return The child nodes
     */
    public List<StateNode> getChildNodes() {
        return childNodes;
    }

    /**
     * Get the parent of the state
     *
     * @return The parent
     */
    public StateNode getParent() {
        return parent;
    }

    /**
     * Add one the the sampled count, meaning a state has been visited
     */
    public void addSampled() {
        numTimesSampled++;
    }

    /**
     * Adds a score to the total
     *
     * @param stateScore The score of the state under the current one to add
     */
    public void addToTotalScore(double stateScore) {
        totalScore += stateScore;
    }

    /**
     * Check if a node is a leaf (children have not been explored)
     *
     * @return Whether the node is a leaf
     */
    public boolean isLeafNode() {
        return childNodes.size() == 0;
    }

    /**
     * Check if the state has a parent
     *
     * @return Whether the state has a parent
     */
    public boolean hasParent() {
        return parent != null;
    }

    /**
     * Get the total score of a state
     *
     * @return The total score
     */
    public double getTotalScore() {
        return totalScore;
    }

    /**
     * Get the number of times a state has been sampled (iterated over)
     *
     * @return The sample count
     */
    public int getSampleCount() {
        return numTimesSampled;
    }

    /**
     * Gets all actions that can be executed in a state
     *
     * @return The actions
     */
    public Action[] getActions() {
        return actions;
    }
}
